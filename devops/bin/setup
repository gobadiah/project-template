#!/bin/zsh

# exit on error
set -e

color=blue

# Path to this file, so we don't have to worry about where this script was
# called from.
SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"

source $SCRIPTPATH/lib/config

print -nP "%F{$color}"
print -nP "Create a k8s cluster, this can take up to a few minutes... "
if [[ "$(kubectl config current-context)" == "$CLUSTER_NAME" ]]; then
  print -nP "%F{cyan}Cluster is already current context%F{$color} "
elif kubectl config get-contexts 2>/dev/null | grep -q " $CLUSTER_NAME "; then
  print -nP "%F{cyan}Cluster is already created, setting current context to it %F{$color}"
  silent kubectl config use-context $CLUSTER_NAME
else
  silent create_cluster --cluster-name $CLUSTER_NAME --wait
fi
print -P "%F{green}done.%F{$color}"

print -nP "Install the kubernetes dashboard for convenience... "
silent kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml
print -P "%F{green}done.%F{$color}"

print -nP "Generate credentials for the dashboard and store them in vault at %F{yellow}$VAULT_CLUSTER_PATH/dashboard%F{$color}... "
DASHBOARD_TOKEN=$(kubectl -n kube-system describe secrets \
   `kubectl -n kube-system get secrets | awk '/clusterrole-aggregation-controller/ {print $1}'` \
   | awk '/token:/ {print $2}')
silent vault write $VAULT_CLUSTER_PATH/dashboard token=$DASHBOARD_TOKEN
print -P "%F{green}done.%F{$color}"

print -nP "Configuring aws secret backend for this cluster in vault... "
silent $SCRIPTPATH/../toolbox/bin/vault-aws-config -path
print -P "%F{green}done.%F{$color}"

print -nP "Configuring k8s auth backend for this cluster in vault... "
silent vault-k8s-config
print -P "%F{green}done.%F{$color}"

print -nP "Peering the cluster vpc to vault vpc... "
VAULT_VPC=$(aws ec2 describe-vpcs \
  --filters "Name=tag:Name,Values=vault.k8s.local" | jq -r ".Vpcs[].VpcId")
VPC=$(aws ec2 describe-vpcs \
  --filters "Name=tag:Name,Values=$CLUSTER_NAME" | jq -r ".Vpcs[].VpcId")
if [[ "$VAULT_VPC" != "" && "$VPC" != "" ]]; then
  if ! aws ec2 describe-vpc-peering-connections |
    jq -e ".VpcPeeringConnections[] | \
      select(.AccepterVpcInfo.VpcId==\"$VAULT_VPC\" and .RequesterVpcInfo.VpcId==\"$VPC\" and .Status.Code!=\"deleted\")" >/dev/null
  then
    peering_connection_id=$(aws ec2 create-vpc-peering-connection \
      --vpc-id $VPC \
      --peer-vpc-id $VAULT_VPC |
      jq -r '.VpcPeeringConnection.VpcPeeringConnectionId')
    silent aws ec2 accept-vpc-peering-connection \
      --vpc-peering-connection-id $peering_connection_id
    vault_cidr=$(aws ec2 describe-vpcs | jq -r ".Vpcs[] | select(.VpcId==\"$VAULT_VPC\") | .CidrBlock")
    vpc_cidr=$(aws ec2 describe-vpcs | jq -r ".Vpcs[] | select(.VpcId==\"$VPC\") | .CidrBlock")
    vault_main_route_table=$(aws ec2 describe-route-tables |
      jq -r ".RouteTables[] | select(.VpcId==\"$VAULT_VPC\") | select(.Associations[0].Main==true) | .RouteTableId")
    vpc_main_route_table=$(aws ec2 describe-route-tables |
      jq -r ".RouteTables[] | select(.VpcId==\"$VPC\") | select(.Associations[0].Main==true) | .RouteTableId")
    aws ec2 describe-route-tables |
      jq -r ".RouteTables[] | select(.VpcId==\"$VAULT_VPC\") | .RouteTableId" |
      xargs -I {} aws ec2 create-route \
        --destination-cidr-block $vpc_cidr \
        --vpc-peering-connection-id $peering_connection_id \
        --route-table-id {}
    aws ec2 describe-route-tables |
      jq -r ".RouteTables[] | select(.VpcId==\"$VPC\") | .RouteTableId" |
      xargs -I {} aws ec2 create-route \
        --destination-cidr-block $vault_cidr \
        --vpc-peering-connection-id $peering_connection_id \
        --route-table-id {}
  fi
fi
print -P "%F{green}done.%F{$color}"

setup_aws_postgres --db-name main
